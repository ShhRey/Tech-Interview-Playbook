# Tech Interview Playbook: DSA & System Design

## üöÄ Introduction

Welcome to my interview preparation repository! This space is dedicated to mastering the core pillars of software engineering interviews: **Data Structures & Algorithms (DSA)** and **System Design**. The goal is to build a strong theoretical foundation and apply it to practical problems, documenting the journey of learning, implementation, and problem-solving along the way.

The primary implementation language here is **Python**, chosen for its clarity and powerful libraries, which makes it ideal for focusing on the logic behind complex concepts.

***

## üéØ Core Topics Covered

This repository is divided into two main sections, each tackling a critical area of computer science.

### 1. Data Structures & Algorithms (DSA) üß†

This section focuses on the fundamental building blocks of efficient software.

* **Core Data Structures**: Lists, Arrays, Stacks, Queues, Linked Lists, Trees, Heaps, Hash Tables, and Graphs.
* **Algorithmic Paradigms**: Brute Force, Recursion, Backtracking, Divide and Conquer, Greedy Algorithms, and Dynamic Programming.
* **Sorting & Searching**: In-depth analysis and implementation of algorithms like Bubble Sort, Insertion Sort, Merge Sort, Quick Sort, Heap Sort, Binary Search, etc.
* **Graph Algorithms**: Traversals (BFS, DFS), Shortest Path (Dijkstra's, Bellman-Ford), and Minimum Spanning Trees (Prim's, Kruskal's).
* **Complexity Analysis**: Understanding and calculating Time and Space Complexity (Big O, Big Œ©, Big Œò notation).

### 2. System Design üèóÔ∏è

This section focuses on the architecture and engineering of robust, scalable, and reliable systems. It is broken down into two key areas: High-Level Design (HLD) and Low-Level Design (LLD).

#### **High-Level Design (HLD)**
HLD focuses on the macro-level, defining the overall system architecture and major components. The goal is to design systems that are scalable, available, and fault-tolerant. Topics to be covered include:

* **Core Concepts**: Scalability (Vertical vs. Horizontal), Availability, Reliability, Latency, and Throughput.
* **Architecture Patterns**: Monolithic, Microservices, Service-Oriented Architecture (SOA), and Serverless.
* **Data Storage**: SQL vs. NoSQL databases, Caching strategies (e.g., Redis, Memcached), Database Sharding, and Replication.
* **System Components**: Load Balancers, API Gateways, Content Delivery Networks (CDNs), and Message Queues (e.g. Kafka).
* **Communication Protocols**: REST APIs, GraphQL, gRPC, and WebSockets.
* **Case Studies**: Applying these concepts to design real-world systems like a URL shortener, a social media feed, an e-commerce site, etc.

#### **Low-Level Design (LLD)**
LLD focuses on the micro-level, detailing the internal logic of specific components, modules, and classes. It's about writing clean, maintainable, and extensible code. My study path for LLD includes:

* **Object-Oriented Programming (OOP) Principles**:
    * **Encapsulation**: Bundling data and methods within a single unit.
    * **Abstraction**: Hiding complex implementation details.
    * **Inheritance**: Creating new classes from existing ones.
    * **Polymorphism**: A single interface for different data types.
* **Class & Object Relationships**:
    * Understanding Association, Aggregation, Composition and Dependency.
* **SOLID Principles**: A guide to writing understandable and maintainable software.
    * **S** - Single Responsibility Principle
    * **O** - Open/Closed Principle
    * **L** - Liskov Substitution Principle
    * **I** - Interface Segregation Principle
    * **D** - Dependency Inversion Principle
* **UML Diagrams**: Visualizing the design of a system.
    * **Class Diagrams**: To represent the static structure and relationships between classes.
    * **Sequence Diagrams**: To model the interactions between objects over time.
* **Design Patterns**: Proven solutions to commonly occurring problems in software design.
    * **Creational Patterns**: (e.g., Singleton, Factory, Builder) - Concerned with object creation mechanisms.
    * **Structural Patterns**: (e.g., Adapter, Decorator, Facade) - Explain how to assemble objects and classes into larger structures.
    * **Behavioral Patterns**: (e.g., Observer, Strategy, Template Method) - Concerned with algorithms and the assignment of responsibilities between objects.

***

## üíª Problem-Solving Platforms

To apply these concepts, I actively solve problems on various online platforms. This repository will feature solutions and key takeaways from:

* **LeetCode**: For a wide range of algorithmic challenges that mimic real interview questions.
* **HackerRank**: For domain-specific exercises that strengthen proficiency in various CS topics.

***

## üìù Personal Notes on Notion

For more detailed breakdowns, thought processes, and in-depth reflections, I maintain a comprehensive set of notes on Notion.

* [**Data Structures & Algorithms Notes on Notion**](https://shreytrivedi577.notion.site/Data-Structures-Algorithms-057f78e59b674e8380168608dd0e52e0)

***

## ü§ù Contributing

This repository is primarily for my personal learning. However, constructive feedback, suggestions for improvement, and collaborative discussions are always welcome!

## üìú Disclaimer

The contents of this repository are for educational purposes. They document my personal journey through these topics and are not intended as a definitive or authoritative guide.